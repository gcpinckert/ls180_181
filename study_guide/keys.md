# Keys

## What are keys

Keys are values that define relationships between different tables in a database, because they allow us to keep track of unique records within tables. In general, a key is any kind of unique identifier for a single record in a table. By calling a value a key, we are providing assurance that the value in question is unique throughout the entire set of data, so that we can use it as an identifier for a single entry. In practice, this is almost always signified by a column of specifically designed values called `id`.

## Natural Keys

A **natural key** is a value that _already exists_ within a dataset used as a unique identifier for a record. It has not be specifically designed for identification use within the database, and usually has some kind of broader application. This might include something like a product code or social security number.

However, in the context of database design, it's almost never a good idea to use a natural key. This is because while it may _appear_ unique, they can have unexpected behaviors, due to the fact that they haven't been specifically designed for use within the database. For example, a product may go through many iterations of development with the same code. How are we to distinguish between these in the context of the table?

One approach to dealing with these issues is to use a _composite key_, which is a key that consists of more than a single value, but this tends to make things more complicated and doesn't usually solve the issue completely anyway.

## Surrogate Keys

A **surrogate key** is a value designed and created specifically to act as a unique identifier for records within a particular database. Because it is designed for use specifically within a database, it solves the issues that come up when using natural keys. These values are created and defined within the database itself, that is, they are not pieces of data that pertain to the entity outside the database at all. This means that forces outside of the database cannot change them.

In practice, a surrogate key is usually an auto-incrementing integer, such as those generated by the datatype `serial`. We refer to the column that stores a surrogate key as `id` in any given table. In terms of database design, a surrogate key **must** be a unique value in order to function properly as an identifier for a row. For this reason, we most often define them as a `PRIMARY KEY`, as this constraint implicitly adds both `UNIQUE` and `NOT NULL` requirements.

## Primary Keys

A **primary key** is a value used to uniquely identify a record within a table. It is typically defined by using the `PRIMARY KEY` constraint on a column with an auto-incrementing integer as default value usually named `id`. The `PRIMARY KEY` constraint implicitly applies both the `UNIQUE` and `NOT NULL` constraints, as these are required for a primary key to serve the purpose of being a unique identifier.

While we can _also_ define a primary key by defining the correct data type and adding `UNIQUE` and `NOT NULL` constraints, by specifying `PRIMARY KEY` explicitly we are basically saying that the column in question can be relied upon to serve this function because it was designed to do so.

## Foreign Keys

A **foreign key** allows us to establish a relationship between records in two different tables. It is a column in a table that _references_ the primary key of another table. We define a foreign key column by setting it to the same datatype as the primary key column it references (usually `integer`) and add the `FOREIGN KEY` constraint.

This constraint ensures that whatever values are present in the foreign key column are _also_ represented in the primary key column it references. Because of this, we must also specify both the referenced table and primary key column with the `REFERENCES` keyword when defining a foreign key column.

This allows us to _normalize_ data within a table, i.e. ensure that it's _referential integrity_ is preserved. Referential integrity promises us that table relationships remain consistent, and that the rules surrounding whatever kind of relationship we have defined will be enforced.

The `ON DELETE` clause allows us to specify what the database should do when preserving this integrity, basically stating what should occur with the foreign key value when the record associated with the primary key it references is deleted. There are three different options:

- `CASCASE` - will delete the entire record containing the foreign key value that is being deleted
- `SET NULL` - will set the value of the foreign key column to `NULL` where the foreign key value is being deleted
- `SET DEFAULT` - will set a new value of whatever is specified as default in the foreign key column where the foreign key is being deleted.
